Noam Mayerfeld
My code checks if CONCUR was entered, or FIFO.
If FIFO was entered, it creates the relevant number of threads, and passes each a function with a void* pointer to a struct containing variables with the relevant information to make its request to the server (with the path alternating, thread by thread, if two files are typed into the command line).
My class contains two global variables a pointer to a semaphore and a pthread barrier. The pointer is subsequently set equal to an array of semaphores – one semaphore per thread.  This array is used to manage the critical section, or the section of work that must be synchronized.  The pthread barrier is used to manage the total work, to ensure that Thread one doesn’t start again before all of the threads have finished their total work. The critical section array has each semaphore initialized to 0, and the pthread barrier is initialized to the number of threads.
Each thread begins by calling wait on the pthread barrier, so none of them can start their work until they have all reached the beginning.  Next, every thread except T1 “downs” the critical section semaphore of the previous thread.  Thus, it will sleep until the previous thread “ups” its critical section semaphore, indicating that it has finished the work that must be synchronized.  The thread then does the work that must be synchronized, finishing by “upping” its critical section semaphore, allowing the next thread to begin.  It then completes all of its work. 
T1 does its work that must be synchronized, calls “up” on its critical section semaphore, allowing T2 to begin, and finishes its work.
If CONCUR was entered, it creates the relevant number of threads, and passes each a function with a void* pointer to a struct containing variables with the relevant information to make its request to the server (with the path it will use alternating each time it runs if two paths were typed into the command line). There is a pthread barrier intitialized to the number of threads, and each thread will call wait to ensure that none can progress to their next round until all of finished the current round.
I tested by using print line statements.  For FIFO, after a thread began its critical work after “downing” the semaphore of the previous thread I had it print “Thread___ beginning critical section.”  Upon completion of the work, but before “upping its semaphore,” I had it print “Thread __ concluding critical section.”  Then, after it finished printing, but before “upping” its total work semaphore, I had it print “Thread ___ completed total work,” so I could ensure that they all finished before Thread 1 started again.  
For CONCUR, after a thread started, it printed Thread ___ beginning, and when it finished (before waiting) it printed Thread __ finished.
I ran the program and made sure the print lines were all in the right order.
